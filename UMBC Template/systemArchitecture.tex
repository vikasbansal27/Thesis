\chapter{System Architecture}
\thispagestyle{plain}


\label{System Architecture}
In this chapter, we are going to present the approaches that we took to solve the problem in hand and then we will finally present our algorithm to recolor web pages.

\section{Initial thoughts and approaches}
\label{Initial approaches}
We started of with a very intuitive idea. We first figured out that which colors are conflicting with rest of the color schema of the web page. After we figure that out, we replace those colors such that there are no more conflicts. In this idea, we need an initial knowledge of what two colors would be conflicting. And in addition to this, we also need to know what would be the ‘safe colors’ which we can put in place of conflicting colors. To get an idea of this algorithm lets see the following example:

For simplicity, lets assume that we are recoloring web pages which are developed using only the following set of colors. Lets call this set as \textbf{U}(Universal Set):
\begin{enumerate}
    \item Black(\#000000)
    \item Blue(\#003366)
    \item Orange(\#FF9900)
    \item Yellow(\#FFCC00)
    \item Red(\#FF0000)
    \item Green(\#00FF00)
    \item White(\#FFFFFF)
\end{enumerate}

To recolor web pages for a particular type of CVD, lets say Protanopia, we need a kind of table like this:

{\vspace{10mm}}
\begin{tikzpicture}
\matrix (first) [table,text width=3em]
{
& Black & Blue & Orange & Yellow & Red & Green & White\\
Black 	& \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
Blue   	& \cmark & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
Orange  & \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark \\
Yellow  & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark & \xmark \\
Red   	& \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark \\
Green   & \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark\\
White   & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark & \xmark\\
};
\end{tikzpicture}
\captionof{figure}{Sample Look Up Table (LUT)}
\label{Tick}

This look up table can help us determine the \textit{conflict} of colors in a webpage. A \textit{conflict} is defined as a situation when two or more colors are seen as similar color by a CVD person, leading to very low differentiability amongst the colors. And since the differentiability is low, one of them should be replaced with a color that can relatively increase the differentiability.

\begin{figure}[!htb]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{hru1.png}
  \caption{As seen by a normal person}
  \label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{hru2.png}
  \caption{As seen by CVD person (Protanopia)}
  \label{fig:sub2}
\end{subfigure}
\caption{Example of conflict}
\label{fig:test}
\end{figure}

As we can see in Fig 3.2(a), two colors having hue properties as Orange and Green map to colors of similar hues, leading to conflict for a CVD person. LUT in Fig 3.1 lists all such conflicts for colors in \textbf{U} which can be experimentally determined.   \\ 



\textbf{Safe colors}


\textit{Safe colors} are the colors which can replace the \textit{conflicting} colors, removing the existing conflict and causing no more additional conflicts. For the given set \textbf{U}, some of the safe colors can be:

\begin{enumerate}
    \item ColorA \#CC00FF
	\item ColorB \#669999
	\item ColorC \#003300
\end{enumerate} 


So our table in Fig 2.1 would look something like this now:

%{\vspace{10mm}}
\begin{tikzpicture}
\matrix (first) [table,text width=3em]
{
& Black & Blue & Orange & Yellow & Red & Green & White & ColorA & ColorB & ColorC\\
Black 	& \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark\\
Blue   	& \cmark & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark\\
Orange  & \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \cmark & \cmark\\
Yellow  & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark\\
Red   	& \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \cmark & \cmark\\
Green   & \cmark & \cmark & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \cmark & \cmark\\
White   & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark\\
ColorA   & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \cmark & \cmark\\
ColorB   & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \cmark\\
ColorC   & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark\\
};
\end{tikzpicture}
\captionof{figure}{Sample Look Up Table (LUT)}
\label{Tick}

\textbf{Recoloring algorithm using LUT and safe colors}


An algorithm such as Algorithm 1 can be implemented to recolor web pages.

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}[!htb]
\caption{Recoloring 1.1}\label{euclid}
\begin{algorithmic}[1]
\Procedure{RecolorWeb(CSSFile)}{}
\State ${ColorsHex,ColorMap} \gets \textit{CSSParser(CSSFile)}$ 
\For{$i \gets 1 \textrm{ to } ColorsHex.length$}
        \For{$j \gets 1 \textrm{ to } ColorsHex.length$}
        	\If {LUT[$i$][$j$] == 0}
        		\State $ColorsHex[i] \gets S[S.length]$
        		\State $S.length \gets S.length - 1$
        	\EndIf
        \EndFor
      \EndFor
\State $NewCSSFile \gets ReplaceColors(CSSFile, ColorsHex, ColorMap)$
\State \textbf{return} $NewCSSFile$
\EndProcedure
\Procedure{CSSParser(CSSFile)}{}
\State $a \gets readLine(CSSFile)$
\State $j \gets 1$
\While{$a \neq EOF$}
    \If {$re.find(\#xxxxxx || rgb(r,g,b) || hsl(h,s,l)) == \textbf{true}$}
    \State $Colors[j] \gets a[StartOfFind:EndOfFind]$
    \State $ColorMap[j++] \gets (StartOfFind,EndOfFind)$
    \EndIf
    \State $a \gets readLine(CSSFile)$
  \EndWhile
\For{$i \gets 1 \textrm{ to } Colors.length$}
\State $ColorsHex[$i$] \gets ToHex(Colors[i])$
\EndFor
\State \textbf{return} $ColorsHex, ColorMap$
\EndProcedure
\Procedure{ReplaceColors(CSSFile, ColorsHex, ColorMap)}{}
\State $a \gets readLine(CSSFile)$
\State $j \gets 1$
\While{$a \neq EOF$}
    \If {$re.find(\#xxxxxx || rgb(r,g,b) || hsl(h,s,l)) == \textbf{true}$}
    \State $a[ColorMap[j][0]:ColorMap[j][1]] \gets ColorsHex[j++]$ 
    \EndIf
    \State $a \gets readLine(CSSFile)$
  \EndWhile
\State \textbf{return} $NewCSSFile$
\EndProcedure
\end{algorithmic}
\end{algorithm}


Another way of recoloring web pages could be to recolor them entirely using a predefined set of non-conflicting colors. Information on how to obtain these safe sets is provided in next section. We can perform Algorithm 2 utilizing these existing sets to recolor web pages:


\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}[!htb]
\caption{Recoloring 1.2}\label{Recolor 1.2}
\begin{algorithmic}[1]
\Procedure{RecolorWeb(CSSFile)}{}
\State ${ColorsHex,ColorMap} \gets \textit{CSSParser(CSSFile)}$ 
\For{$i \gets 1 \textrm{ to } ColorsHex.length$}
	\For{$j \gets 1\textrm{ to } SETS.length$} \Comment{SETS contains the predefined set of non-conflicting colors}
        \If{$ColorsHex[i] \in SETS[j]$}
        		\State $Replaced \gets i$ \Comment{Helps in keeping the original color and thus naturalness}
        		\State $SetChosen \gets j$
        		\State \textbf{break}
        	\EndIf
        \EndFor
      \EndFor
\For{$i \gets 1 \textrm{ to } ColorsHex.length$}
	\If{$i==Replaced$} 
	\State	\textbf{continue}
	\EndIf
	\State $ColorsHex[i] \gets SETS[j][i]$
\EndFor
\State $NewCSSFile \gets ReplaceColors(CSSFile, ColorsHex, ColorMap)$
\State \textbf{return} $NewCSSFile$
\EndProcedure
\Procedure{CSSParser(CSSFile)}{}
\State \textit{Defined in Algorithm 1}
\EndProcedure
\Procedure{ReplaceColors(CSSFile, ColorsHex, ColorMap)}{}
\State \textit{Defined in Algorithm 1}
\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsection{How to obtain safe colors?}
\label{Obtaining safe colors}
Most accurate way of obtaining these safe colors would be to show a set of colors to CVD users and then classify the colors as \textit{safe} or \textit{conflicting}. Although degree of CVD may slightly vary from user to user but we assume in our study that a safe set developed for some of the CVD users is applicable to most of them. 

A similar study was done by [5]. They obtained a color palette as seen by a CVD users. 

\begin{figure}[!htb]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{ColorMapNormal.png}
  \caption{As seen by a normal person}
  \label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{ColorMapCVD.png}
  \caption{As seen by CVD person (Protanopia)}
  \label{fig:sub2}
\end{subfigure}
\caption{Color Palette}
\label{fig:test}
\end{figure}

As we can observe, a CVD person can only see a subset of all possible colors. In other words, an entire set of colors(Fig 3.4(a)) is mapped to only a few different colors(Fig 3.4(b)). It is very probable that if two random colors are put into a single web page, they map to two colors that have very little differentiability between them. If they are used in background and text formatting, a color blind person won't be able to read the text, which might be a crucial aspect from a website designers point of view. To resolve this, we need a particular set of colors, which when used together, map to colors having significant differentiability for a CVD user.


Lets say there are two colors in a web page \textit{C1} and \textit{C2} as seen by a normal person. They will be seen as \textit{C1'} and \textit{C2'} by a CVD user. \textit{C1'} and \textit{C2'} should be differentiable enough for a CVD person to read the content on the web page. Idea is to replace \textit{C1} and \textit{C2} with \textit{D1} and \textit{D2} such that \textit{D1'} and \textit{D2'}, as seen by a CVD user, are differentiable enough.





\subsubsection{Limitations of this approach}
\label{Limitatios}

\begin{itemize}
\item{We will have to manually generate a finite number of sets from the palette available at [5], so that we can choose a particular set while recoloring.} 
\item{Still, there can be a case in which none of the colors in \textit{ColorHex} belongs to any of the sets, which restricts the scope of this approach.}
\item{This approach leads to bad \textit{perceptual naturalness}, as the complete set of original CSS colors will be replaced with a newer one.}
\end{itemize}


\subsection{SPRWeb}
\label{SPRWeb}

SPRweb[] by David et. al. is a tool that recolors websites to preserve subjective responses and improve color differentiability – thus enabling users with CVD to have similar on-line experiences. To recolor web pages, it uses a mapping available in DTEP(Dichromacy Trichromacy Equivalence Plane) set.


To find the DTEP set previous researches, have used findings from unilateral dichromats (individuals who are dichromatic in one eye, but are trichromatic in the other) to identify the set of colors that are perceived identically in dichromatic color vision and typical color vision. 

DTEP set contains all the colors which are perceived same as by a normal person and a CVD person. It also lists all the colors which are perceived by a CVD person. 

The key difference in our initial approach and that of SPRweb is the availability of a bigger set of colors and the inclusion of optimization of cost corresponding to \textit{perceptual naturalness}, \textit{perceptual differentiability}, \textit{subjective naturalness} and \textit{subjective differentiability.}

We developed following algorithm implementing approach mentioned in SPRWeb to compare its performance with our final algorithm. 


\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{algorithm}[!htb]
\caption{SPRWeb}\label{SPRWeb}
\begin{algorithmic}[1]
\Procedure{SPRWeb(CSSFile)}{}
\State ${ColorsHex,ColorMap} \gets \textit{CSSParser(CSSFile)}$
\State $ColorsOrig \gets HexToCIELab(ColorsHex)$
\State $DTEPSampled \gets UniformSample(DTEP,900)$ \Comment{gets 900 uniform samples from DTEP}
\State $ColorsRep \gets RAND(DTEPSampled,ColorsOrig.length)$ \Comment{Initializing Replaced color set with random colors from DTEPSampled}
\State $FirstOuput \gets FirstPass(ColorsOrig,ColorsRep,DTEPSampled)$
\For{$i \gets 1 \textrm{ to } FirstOuput.length$}
	\For{$j \gets 1\textrm{ to } DTEP$}
		\If{$distance(FirstOuput[i],DTEP[j]) < 5$} \Comment {Looks for all the points at 5 Lab units }
			\State $DTEPFiltered[i].append(DTEP[j])$
		\EndIf
	\EndFor
\EndFor
\State $FinalOutput\gets SecondPass(ColorsOrig,FirstOuput,DTEPFiltered)$
\State $ColorsHex \gets CIELabToHex(FinalOutput)$
\State $NewCSSFile \gets ReplaceColors(CSSFile, ColorsHex, ColorMap)$
\State \textbf{return} $NewCSSFile$
\EndProcedure
\algstore{myalg}

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{SPRWeb:continue}\label{SPRWeb:continue}
\begin{algorithmic}[1]
\algrestore{myalg}
\Procedure{FirstPass(ColorsOrig,ColorsRep,DTEPSampled)}{}
\State $cost \gets CalculateCost(ColorsOrig,ColorsRep)$
\State $ColorRep1 \gets ColorsRep$  \Comment{Initializing a variable to check optimization}
\While {$\textbf{true}$}
	\For{$i \gets 1 \textrm{ to } ColorsRep.length$}
		\For{$j \gets 1\textrm{ to } DTEPSampled$}
			\State $Value \gets ColorsRep[i]$
			\State $ColorsRep[i] \gets DTEPSampled[j]$ \Comment{trying a new color from DTEPSampled}
			\State $NewCost \gets CalculateCost(ColorsOrig,ColorsRep)$  \Comment{Calculating new cost after the change}
	        \If{$NewCost > cost$} 
	        		\State $ColorsRep[i] \gets Value$ \Comment{increased cost, Rejecting the color}
	        	\EndIf
	        \EndFor
	      \EndFor
	\State $ColorsRep2 \gets ColorsRep1$
	\State $ColorsRep1 \gets ColorRep$
	\If{$ColorsRep1 == ColorRep2$}
		\State $\textbf{break}$
	\EndIf
\EndWhile
\State $\textbf{return}  ColorRep1$
\EndProcedure
\Procedure{CSSParser(CSSFile)}{}
\State \textit{Defined in Algorithm 1}
\EndProcedure
\Procedure{ReplaceColors(CSSFile, ColorsHex, ColorMap)}{}
\State \textit{Defined in Algorithm 1}
\EndProcedure
\algstore{myalg}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{SPRWeb:continue}\label{SPRWeb:continue2}
\begin{algorithmic}[1]
\algrestore{myalg}
\Procedure{SecondPass(ColorsOrig,ColorsRep,DTEPFiltered)}{}
\State $cost \gets CalculateCost(ColorsOrig,ColorsRep)$
\State $ColorRep1 \gets ColorsRep$  \Comment{Initializing a variable to check optimization}
\While {$\textbf{true}$}
	\For{$i \gets 1 \textrm{ to } ColorsRep.length$}
		\For{$j \gets 1\textrm{ to } DTEPFiltered[i]$}
			\State $Value \gets ColorsRep[i]$
			\State $ColorsRep[i] \gets DTEPFiltered[i][j]$ \Comment{trying a new color from DTEPSampled}
			\State $NewCost \gets CalculateCost(ColorsOrig,ColorsRep)$  \Comment{Calculating new cost after the change}
	        \If{$NewCost > cost$} 
	        		\State $ColorsRep[i]\gets Value$ \Comment{increased cost, Rejecting the color}
	        	\EndIf
	        \EndFor
	      \EndFor
	\State $ColorsRep2 \gets ColorsRep1$
	\State $ColorsRep1 \gets ColorRep$
	\If{$ColorsRep1 == ColorRep2$}
		\State $\textbf{break}$
	\EndIf
\EndWhile
\State $\textbf{return}  ColorRep1$
\EndProcedure
\algstore{myalg}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{SPRWeb:continue}\label{SPRWeb:continue3}
\begin{algorithmic}[1]
\algrestore{myalg}
\Procedure{CalculateCost(ColorsOrig,ColorsRep)}{}
\State $pn \gets PercepNaturalness(ColorsOrig,ColorsRep)$
\State $pd \gets PercepDifferentiability(ColorsOrig,ColorsRep)$
\State $spn \gets SubNaturalness(ColorsOrig,ColorsRep)$
\State $spd \gets SubDifferentiability(ColorsOrig,ColorsRep)$
\State $cost \gets pn + pd + spn + spd$
\State \textbf{return} $cost$
\EndProcedure

\Procedure{PercepNaturalness(ColorsOrig,ColorsRep)}{}
\State $pn \gets 0$
\For{$i \gets 1 \textrm{ to } ColorsOrig.length$}
	\State $pn \gets pn + distance(ColorsOrig[i],ColorsRep[i])$
\EndFor
\State $pn \gets pn/ColorsOrig.length$
\State \textbf{return} $pn$
\EndProcedure

\Procedure{PercepDifferentiability(ColorsOrig,ColorsRep)}{}
\State $pd \gets 0$
\For{$i \gets 1 \textrm{ to } ColorsOrig.length$}
	\For{$j \gets i+1 \textrm{ to } ColorsRep.length$}
		\State $pd \gets pd + abs(distance(ColorsOrig[i],ColorsOrig[j]) - distance(ColorsRep[i],ColorsRep[j]))$
	\EndFor
\EndFor
\State $pd \gets pd/((ColorsOrig.length)*(ColorsOrig.length-1))$
\State \textbf{return} $pd$
\EndProcedure
\algstore{myalg}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!htb]
\caption{SPRWeb:continue}\label{SPRWeb:continue4}
\begin{algorithmic}[1]
\algrestore{myalg}
\Procedure{SubNaturalness(ColorsOrig,ColorsRep)}{}
\State \textbf{return} $PercepNaturalness(Sub(ColorsOrig),Sub(ColorsRep))$
\EndProcedure
\Procedure{SubDifferentiability(ColorsOrig,ColorsRep)}{}
\State \textbf{return} $PercepDifferentiability(Sub(ColorsOrig),Sub(ColorsRep))$
\EndProcedure
\Procedure{Sub(Color)}{}   \Comment{Transforms a color to the subjective space}
\State $L \gets Color[0]$
\State $a \gets Color[1]$
\State $b \gets Color[2]$
\If{$a == 90$}
	\State $H \gets 90$
\Else
	\State $H \gets tan^{-1}b/a$
\EndIf
\State $C \gets sqrt({a^{2}+b^{2}})$
\State $activity \gets -2.1 + 0.06*sqrt({(l-50)^{2}+(a-3)^{2}+((b-17)/1.4)^{2}})$
\State $temp\gets -0.5 + 0.02*C^{1.07}*cos(H-50)$
\State $weight\gets -1.8 + 0.04*(100-l) + 0.45*cos(H-100)$
\State \textbf{return} ($activity$,$temp$,$weight$)
\EndProcedure
\end{algorithmic}
\end{algorithm}


\subsubsection{Performance Improvement in SPRWeb}
\label{Improvement in SPRWeb}
While implementing SPRWeb to do performance comparison, we came across some redundant calculations which were happening at every step. By storing the result of those calculations once and then reusing them gave us a significant performance improvement.

\begin{itemize}
\item {Improvement Naturalness cost calculation:} Procedure \textit{PercepNaturalness} in Algorithm 6 computes a summation and has a time complexity of \textbf{O(n)} where n is the number of colors parsed from CSS file. And \textit{PercepNaturalness} is called every time we make a change in our \textit{ColorRep} set during optimization.

Instead of computing whole summation every time, we can compute the summation only once and then make changes in that for further replacement (because at each step only one color is being replaced and we can just change the sum according to that rather than re-computing whole summation), thus reducing computations.

We can rewrite our \textit{PercepNaturalness} procedure as shown in Algorithm 8. As we can see that the \text{for} loop for summation will get executes only once. Thus the time complexity of one call to \textit{PercepNaturalness} has an average cost of \textbf{O(1)} instead of \textbf{O(n)}.

Some other changes such as passing the value of of the index where the colors is getting replaced and the value of color which is getting replaced will have to be passed as well to the \textit{CalculateCost} procedure. But they all can be done without any added complexity. 

\begin{algorithm}[!htb]
\caption{Improvements in SPRWeb}\label{Improvements Naturalness}
\begin{algorithmic}[1]
\Procedure{PercepNaturalness(ColorsOrig,ColorsRep,$k$,OldColor)}{} \Comment{k=index of replacement, OldColor = Color being replaced}
\If {$pn == InitialzedValue$}  \Comment{is true only once - during first computation of cost}
		\For{$i \gets 1 \textrm{ to } ColorsOrig.length$}
			\State $pn \gets pn + distance(ColorsOrig[i],ColorsRep[i])$
		\EndFor
	\State $pn \gets pn/ColorsOrig.length$
\Else
\State $pn \gets pn*ColorsOrig.length$
\State $pn  \gets pn - distance(ColorsOrig[k],OldColor) + distance(ColorsOrig[k],ColorRep[k])$ 
\EndIf
\State \textbf{return} $pn$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\item {Improvement differentiability cost calculation:}  Procedure \textit{PercepDifferentiability} in Algorithm 6 computes a double summation and has a time complexity of \textbf{O($n^{2}$)} where $n$ is the number of colors parsed from CSS file. And \textit{PercepDifferentiability} is called every time we make a change in our \textit{ColorRep} set during optimization process.


Instead of computing the two summations every time, we can compute the inner summation only once and then make changes in that for further replacement (because at each step only one color is being replaced and we can just change the sum according to that change rather than re-computing the double summation), thus reducing computations.

We can rewrite our \textit{PercepDifferentiability} procedure as shown in Algorithm 9. As we can see that the inner \text{for} loop for summation will get executes only once. Thus the time complexity of one call to \textit{PercepNaturalness} has an average cost of
O(n).


\begin{algorithm}[!htb]
\caption{Improvements in SPRWeb}\label{Improvements differentiability}
\begin{algorithmic}[1]
\Procedure{PercepDifferentiability(ColorsOrig,ColorsRep,$k$,OldColor)}{} \Comment{k=index of replacement, OldColor = Color being replaced}
\If {$pd == InitialzedValue$}  \Comment{is true only once - during first computation of cost}
		\For{$i \gets 1 \textrm{ to } ColorsOrig.length$}
			\For{$j \gets i+1 \textrm{ to } ColorsRep.length$}
				\State $pd \gets pd + abs(distance(ColorsOrig[i],ColorsOrig[j]) - distance(ColorsRep[i],ColorsRep[j]))$
			\EndFor
		\EndFor
		\State $pd \gets pd/((ColorsOrig.length)*(ColorsOrig.length-1))$
\Else 
\State $pd \gets pd*((ColorsOrig.length)*(ColorsOrig.length-1))$
\For{$i \gets 1 \textrm{ to } ColorsOrig.length$}
	\State $pd  \gets pd - abs(distance(ColorsOrig[i],ColorsOrig[k]) - distance(ColorsRep[i],OldColor))$
	\State $pd  \gets pd + abs(distance(ColorsOrig[i],ColorsOrig[k]) - distance(ColorsRep[i],ColorRep[k]))$
\EndFor
\State $pd \gets pd/((ColorsOrig.length)*(ColorsOrig.length-1))$
\EndIf
\State \textbf{return} $pd$
\EndProcedure
\end{algorithmic}
\end{algorithm}


\end{itemize}

\subsection{SECTION-TITLE}
\label{SECTION-LABEL}